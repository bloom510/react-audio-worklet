{"version":3,"sources":["App.js","serviceWorker.js","index.js","logo.svg"],"names":["App","_this","Object","classCallCheck","this","possibleConstructorReturn","getPrototypeOf","call","state","selected","moduleLoaded","isPlaying","menu","react_default","a","createElement","es_menu","onClick","e","handleSelect","selectedKeys","current","Item","key","custom","moduleName","actx","audioWorklet","addModule","concat","setState","console","log","bypasserNode","AudioWorkletNode","oscillator","createOscillator","connect","destination","start","beginning","currentTime","middle","end","filterNode","parameters","get","setValueAtTime","exponentialRampToValueAtTime","sampleRate","modulator","OscillatorNode","modGain","GainNode","noiseGeneratorNode","paramAmp","frequency","value","gain","bitCrusherNode","paramBitDepth","paramReduction","type","linearRampToValueAtTime","stop","window","AudioContext","webkitAudioContext","loadModule","port","postMessage","bypassProcessor","onePoleProcessor","noiseGenerator","bitCrusherProcessor","_this2","className","src","logo","alt","style","float","width","dropdown","overlay","size","href","icon","es_button","ghost","handleClick","marginLeft","Component","Boolean","location","hostname","match","ReactDOM","render","src_App_0","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","module","exports","__webpack_require__","p"],"mappings":"8TAyNeA,cAnNb,SAAAA,IAAc,IAAAC,EAAA,OAAAC,OAAAC,EAAA,EAAAD,CAAAE,KAAAJ,IACZC,EAAAC,OAAAG,EAAA,EAAAH,CAAAE,KAAAF,OAAAI,EAAA,EAAAJ,CAAAF,GAAAO,KAAAH,QACKI,MAAQ,CACXC,SAAU,KACVC,cAAc,EACdC,WAAW,GAGbV,EAAKW,KACHC,EAAAC,EAAAC,cAACC,EAAA,EAAD,CAAMC,QAAS,SAACC,GAAD,OAAOjB,EAAKkB,aAAaD,IAAIE,aAAc,CAACnB,EAAKO,MAAMa,UACpER,EAAAC,EAAAC,cAACC,EAAA,EAAKM,KAAN,CAAWC,IAAI,gBAAgBC,OAAO,QAAtC,iBAGAX,EAAAC,EAAAC,cAACC,EAAA,EAAKM,KAAN,CAAWC,IAAI,mBAAf,mBAGAV,EAAAC,EAAAC,cAACC,EAAA,EAAKM,KAAN,CAAWC,IAAI,SAAf,SAGAV,EAAAC,EAAAC,cAACC,EAAA,EAAKM,KAAN,CAAWC,IAAI,cAAf,eAnBQtB,kHA0BGwB,gFACPC,EAAStB,KAATsB,uBAEAA,EAAKC,aAAaC,UAAlB,WAAAC,OACOJ,EADP,eAGNrB,KAAK0B,SAAS,CAACpB,cAAc,IAC7BqB,QAAQC,IAAR,iBAAAH,OAA6BJ,oDAE7BrB,KAAK0B,SAAS,CAACpB,cAAc,IAC7BqB,QAAQC,IAAR,yBAAAH,OAAqCJ,0JAKvB,IACRC,EAAStB,KAATsB,KACRtB,KAAK6B,aAAe,IAAIC,iBAAiBR,EAAM,oBAC/CtB,KAAK+B,WAAaT,EAAKU,mBACvBhC,KAAK+B,WAAWE,QAAQjC,KAAK6B,cAAcI,QAAQX,EAAKY,aACxDlC,KAAK+B,WAAWI,mDAOG,IACTb,EAAStB,KAATsB,KAEFc,EAAYd,EAAKe,YACjBC,EAAShB,EAAKe,YAAc,EAC5BE,EAAMjB,EAAKe,YAAc,EAE/BrC,KAAKwC,WAAa,IAAIV,iBAAiBR,EAAM,sBAC7CtB,KAAK+B,WAAaT,EAAKU,mBACvBhC,KAAK+B,WAAWE,QAAQjC,KAAKwC,YAAYP,QAAQX,EAAKY,aACtDlC,KAAK+B,WAAWI,QAEOnC,KAAKwC,WAAWC,WAAWC,IAAI,aAEjDC,eAAe,IAAMP,GACrBQ,6BAA+C,GAAlBtB,EAAKuB,WAAkBP,GACpDM,6BAA6B,IAAML,4CAOzB,IACPjB,EAAStB,KAATsB,KACFwB,EAAY,IAAIC,eAAezB,GAC/B0B,EAAU,IAAIC,SAAS3B,GAC7BtB,KAAKkD,mBAAqB,IAAIpB,iBAAiBR,EAAM,mBACrDtB,KAAKkD,mBAAmBjB,QAAQX,EAAKY,aAErC,IAAMiB,EAAWnD,KAAKkD,mBAAmBT,WAAWC,IAAI,aACxDI,EAAUb,QAAQe,GAASf,QAAQkB,GACnCL,EAAUM,UAAUC,MAAQ,GAC5BL,EAAQM,KAAKD,MAAQ,IACrBP,EAAUX,sDAEU,IACZb,EAAStB,KAATsB,KACRtB,KAAK+B,WAAaT,EAAKU,mBACvBhC,KAAKuD,eAAiB,IAAIzB,iBAAiBR,EAAM,yBACjD,IAAMkC,EAAgBxD,KAAKuD,eAAed,WAAWC,IAAI,YACnDe,EAAiBzD,KAAKuD,eAAed,WAAWC,IAAI,sBAC1D1C,KAAK+B,WAAW2B,KAAO,WACvB1D,KAAK+B,WAAWqB,UAAUC,MAAQ,IAClCG,EAAcb,eAAe,EAAG,GAChC3C,KAAK+B,WAAWE,QAAQjC,KAAKuD,gBAAgBtB,QAAQX,EAAKY,aAC1D,IAAME,EAAYd,EAAKe,YACjBC,EAAShB,EAAKe,YAAc,EAC5BE,EAAMjB,EAAKe,YAAc,EAG/BoB,EAAed,eAAe,IAAMP,GACpCqB,EAAeE,wBAAwB,GAAKrB,GAC5CmB,EAAeb,6BAA6B,IAAML,GAElDvC,KAAK+B,WAAWI,QAChBnC,KAAK+B,WAAW6B,KAAKrB,wCAGZzB,GAGX,GAFAd,KAAK0B,SAAS,CAACrB,SAAUS,EAAEK,IAAKb,cAAc,KAE1CN,KAAKsB,KACP,IACEK,QAAQC,IAAI,4BACZ5B,KAAKsB,KAAO,IAAKuC,OAAOC,cAAgBD,OAAOE,oBAC/C,MAAMjD,GACJa,QAAQC,IAAR,6DAA0Ed,GAGhF,OAAOA,EAAEK,KACP,QACE,OAEF,IAAK,gBACHnB,KAAKgE,WAAW,oBAChB,MACF,IAAK,kBACHhE,KAAKgE,WAAW,sBAChB,MACF,IAAK,QACHhE,KAAKgE,WAAW,mBAChB,MACF,IAAK,aACHhE,KAAKgE,WAAW,gEAKR,IACJ5D,EAAUJ,KAAVI,MAIR,OAHGA,EAAMC,UACPL,KAAK0B,SAAS,CAACnB,WAAYH,EAAMG,YAE5BH,EAAMC,UACX,IAAK,gBACED,EAAMG,WACPoB,QAAQC,IAAR,YAAAH,OAAwBrB,EAAMC,WAC9BL,KAAK6B,aAAaoC,KAAKC,aAAY,KAEnCvC,QAAQC,IAAR,WAAAH,OAAuBrB,EAAMC,WAC7BL,KAAKmE,kBACLnE,KAAK6B,aAAaoC,KAAKC,aAAY,IAErC,MACJ,IAAK,kBACA9D,EAAMG,WACPoB,QAAQC,IAAR,YAAAH,OAAwBrB,EAAMC,WAC9BL,KAAKwC,WAAWyB,KAAKC,aAAY,KAEjCvC,QAAQC,IAAR,WAAAH,OAAuBrB,EAAMC,WAC7BL,KAAKoE,mBACLpE,KAAKwC,WAAWyB,KAAKC,aAAY,IAEnC,MACA,IAAK,QACA9D,EAAMG,WACPoB,QAAQC,IAAR,YAAAH,OAAwBrB,EAAMC,WAC9BL,KAAKkD,mBAAmBe,KAAKC,aAAY,KAEzCvC,QAAQC,IAAR,WAAAH,OAAuBrB,EAAMC,WAC7BL,KAAKqE,iBACLrE,KAAKkD,mBAAmBe,KAAKC,aAAY,IAE7C,MACA,IAAK,aACF9D,EAAMG,WACPoB,QAAQC,IAAR,YAAAH,OAAwBrB,EAAMC,WAC9BL,KAAKuD,eAAeU,KAAKC,aAAY,KAErCvC,QAAQC,IAAR,WAAAH,OAAuBrB,EAAMC,WAC7BL,KAAKsE,sBACLtE,KAAKuD,eAAeU,KAAKC,aAAY,sCAKpC,IAAAK,EAAAvE,KACCI,EAAgBJ,KAAhBI,MAAOI,EAASR,KAATQ,KACf,OACEC,EAAAC,EAAAC,cAAA,OAAK6D,UAAU,OACb/D,EAAAC,EAAAC,cAAA,UAAQ6D,UAAU,cAChB/D,EAAAC,EAAAC,cAAA,OAAK8D,IAAKC,IAAMF,UAAU,WAAWG,IAAI,SACzClE,EAAAC,EAAAC,cAAA,6CACAF,EAAAC,EAAAC,cAAA,OAAKiE,MAAO,CAACC,MAAM,OAAQC,MAAO,SAChCrE,EAAAC,EAAAC,cAACoE,EAAA,EAAD,CAAUC,QAASxE,EAAMyE,KAAK,SAC5BxE,EAAAC,EAAAC,cAAA,KAAG6D,UAAU,oBAAoBU,KAAK,KACnC9E,EAAMC,SAAWD,EAAMC,SAAW,kBADrC,IACwDI,EAAAC,EAAAC,cAACwE,EAAA,EAAD,CAAMzB,KAAK,WAGrEjD,EAAAC,EAAAC,cAACyE,EAAA,EAAD,CAAQC,OAAK,EAACxE,QAAS,kBAAM0D,EAAKe,eAAeV,MAAO,CAACW,WAAW,OAAQnF,EAAMG,UAAY,OAAS,mBA5MjGiF,aCOEC,QACW,cAA7B5B,OAAO6B,SAASC,UAEe,UAA7B9B,OAAO6B,SAASC,UAEhB9B,OAAO6B,SAASC,SAASC,MACvB,2DCXNC,IAASC,OAAOrF,EAAAC,EAAAC,cAACoF,EAAD,MAASC,SAASC,eAAe,SD0H3C,kBAAmBC,WACrBA,UAAUC,cAAcC,MAAMC,KAAK,SAAAC,GACjCA,EAAaC,mCEnInBC,EAAAC,QAAiBC,EAAAC,EAAuB","file":"static/js/main.48b14726.chunk.js","sourcesContent":["import React, { Component } from 'react';\nimport logo from './logo.svg';\nimport './App.css';\nimport { Menu, Dropdown, Icon, Button } from 'antd';\n\nclass App extends Component {\n  constructor() {\n    super();\n    this.state = {\n      selected: null, /* Which module has been selected from the menu */\n      moduleLoaded: false, /* Has the current selected module finished loading? */\n      isPlaying: false /* Is a module currently playing? */\n    }\n    /* Menu is an overlay for the Ant Design dropdown component, passed in via props. */\n    this.menu = (\n      <Menu onClick={(e) => this.handleSelect(e)} selectedKeys={[this.state.current]}>\n        <Menu.Item key=\"Bypass Filter\" custom='prop'>\n          Bypass Filter\n        </Menu.Item>\n        <Menu.Item key=\"One Pole Filter\">\n          One Pole Filter\n        </Menu.Item>\n        <Menu.Item key=\"Noise\">\n          Noise\n        </Menu.Item>\n        <Menu.Item key=\"Bitcrusher\">\n          Bitcrusher\n        </Menu.Item>   \n      </Menu>\n    );\n  }\n  /* The function below takes module name as an arg and adds it to the AudioContext's audioWorklet */\n  async loadModule(moduleName) {\n    const { actx } = this;   \n    try {\n      await actx.audioWorklet.addModule(\n        `worklet/${moduleName}.js`,\n      );\n      this.setState({moduleLoaded: true})\n      console.log(`loaded module ${moduleName}`);\n    } catch(e) {\n      this.setState({moduleLoaded: false})\n      console.log(`Failed to load module ${moduleName}`);\n    }\n  }\n  /* The function below creates an AudioWorkletNode, connects it to our AudioContext,\n     connects an oscillator to it, and starts the oscillator */\n  bypassProcessor() {\n    const { actx } = this;\n    this.bypasserNode = new AudioWorkletNode(actx, 'bypass-processor');\n    this.oscillator = actx.createOscillator();\n    this.oscillator.connect(this.bypasserNode).connect(actx.destination);\n    this.oscillator.start();\n  }\n/* The example below initially demonstrated a one-off scheduled event. I've modified it to play\n    based on the AudioContext's currentTime so that it can be replayed at the press of a button. \n    It creates a new AudioWorkletNode and a new oscillator, connects the new oscillator to the \n    node, starts the oscillator, schedules it's termination, and fiddles with the node's frequency\n    parameter during playback. */\n    onePoleProcessor() {\n      const { actx } = this;\n\n      const beginning = actx.currentTime;\n      const middle = actx.currentTime + 4;\n      const end = actx.currentTime + 8;\n\n      this.filterNode = new AudioWorkletNode(actx, 'one-pole-processor');\n      this.oscillator = actx.createOscillator();\n      this.oscillator.connect(this.filterNode).connect(actx.destination);\n      this.oscillator.start();\n\n      const frequencyParam = this.filterNode.parameters.get('frequency');\n      frequencyParam\n          .setValueAtTime(0.01, beginning)\n          .exponentialRampToValueAtTime(actx.sampleRate * 0.5, middle)\n          .exponentialRampToValueAtTime(0.01, end);\n\n      // This implementation of osc.onended is glitchy because the beginning, middle, and end must be managed in state.\n      // this.oscillator.onended = () => {\n      //     this.setState({ isPlaying: false })\n      // }\n    }\n    noiseGenerator() {\n      const { actx } = this;\n      const modulator = new OscillatorNode(actx);\n      const modGain = new GainNode(actx);\n      this.noiseGeneratorNode = new AudioWorkletNode(actx, 'noise-generator');\n      this.noiseGeneratorNode.connect(actx.destination);\n      // Connect the oscillator to 'amplitude' AudioParam.\n      const paramAmp = this.noiseGeneratorNode.parameters.get('amplitude');\n      modulator.connect(modGain).connect(paramAmp);\n      modulator.frequency.value = 0.5;\n      modGain.gain.value = 0.75;\n      modulator.start();\n    }\n    bitCrusherProcessor() {\n      const { actx } = this;\n      this.oscillator = actx.createOscillator();\n      this.bitCrusherNode = new AudioWorkletNode(actx, 'bit-crusher-processor');\n      const paramBitDepth = this.bitCrusherNode.parameters.get('bitDepth');\n      const paramReduction = this.bitCrusherNode.parameters.get('frequencyReduction');\n      this.oscillator.type = 'sawtooth';\n      this.oscillator.frequency.value = 5000;\n      paramBitDepth.setValueAtTime(1, 0);\n      this.oscillator.connect(this.bitCrusherNode).connect(actx.destination);\n      const beginning = actx.currentTime;\n      const middle = actx.currentTime + 4;\n      const end = actx.currentTime + 8;\n      // |frequencyReduction| parameters will be automated and changing over\n      // time. Thus its parameter array will have 128 values.\n      paramReduction.setValueAtTime(0.01, beginning);\n      paramReduction.linearRampToValueAtTime(0.1, middle);\n      paramReduction.exponentialRampToValueAtTime(0.01, end);\n      // Play the tone for 8 seconds.\n      this.oscillator.start();\n      this.oscillator.stop(end);\n    }\n  /* The function below loads modules when selected from the dropdown menu. */\n  handleSelect(e) {\n    this.setState({selected: e.key, moduleLoaded: false});\n    /* If no AudioContext, instantiate one and load modules */\n    if(!this.actx) {\n      try {\n        console.log('New context instantiated')\n        this.actx = new (window.AudioContext || window.webkitAudioContext)();\n      } catch(e) {\n          console.log(`Sorry, but your browser doesn't support the Web Audio API!`, e);\n      }\n    } \n    switch(e.key) {\n      default:\n        return;\n        break;\n      case 'Bypass Filter':\n        this.loadModule('bypass-processor')\n        break;\n      case 'One Pole Filter':\n        this.loadModule('one-pole-processor')\n        break;\n      case 'Noise':\n        this.loadModule('noise-generator');\n        break;\n      case 'Bitcrusher':\n        this.loadModule('bit-crusher-processor')\n        break;\n    }\n  }\n  /* The function below handles the starting and stopping of the currently loaded module.  */\n  handleClick() {\n    const { state } = this;\n    if(state.selected) {\n      this.setState({isPlaying: !state.isPlaying});    \n    }    \n    switch(state.selected) {\n      case 'Bypass Filter':\n          if(state.isPlaying) {\n            console.log(`stopping ${state.selected}`)\n            this.bypasserNode.port.postMessage(false)\n          } else {\n            console.log(`playing ${state.selected}`)\n            this.bypassProcessor();\n            this.bypasserNode.port.postMessage(true);          \n          }\n          break;\n      case 'One Pole Filter':\n        if(state.isPlaying) {\n          console.log(`stopping ${state.selected}`)\n          this.filterNode.port.postMessage(false);          \n        } else {\n          console.log(`playing ${state.selected}`)\n          this.onePoleProcessor();\n          this.filterNode.port.postMessage(true);          \n        }\n        break;\n        case 'Noise':\n          if(state.isPlaying) {\n            console.log(`stopping ${state.selected}`)\n            this.noiseGeneratorNode.port.postMessage(false);          \n          } else {\n            console.log(`playing ${state.selected}`)\n            this.noiseGenerator();\n            this.noiseGeneratorNode.port.postMessage(true);          \n          }\n        break;\n        case 'Bitcrusher':\n        if(state.isPlaying) {\n          console.log(`stopping ${state.selected}`)\n          this.bitCrusherNode.port.postMessage(false);          \n        } else {\n          console.log(`playing ${state.selected}`)\n          this.bitCrusherProcessor();\n          this.bitCrusherNode.port.postMessage(true);          \n        }\n        break;\n    }\n  }\n  render() {\n    const { state, menu } = this;\n    return (\n      <div className=\"App\">\n        <header className=\"App-header\">\n          <img src={logo} className=\"App-logo\" alt=\"logo\" />\n          <span>React + AudioWorklet = ❤</span>\n          <div style={{float:'left', width: '100%'}}>\n            <Dropdown overlay={menu} size='small'>\n              <a className=\"ant-dropdown-link\" href=\"#\">\n                {state.selected ? state.selected : 'Select a module'} <Icon type=\"down\" />\n              </a>\n            </Dropdown>\n            <Button ghost onClick={() => this.handleClick()} style={{marginLeft:'1%'}}>{state.isPlaying ? 'Stop' : 'Start'}</Button>\n          </div>\n        </header>\n      </div>\n    );\n  }\n}\n\nexport default App;","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read http://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit http://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See http://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport 'antd/dist/antd.css'\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\nserviceWorker.unregister();\n","module.exports = __webpack_public_path__ + \"static/media/logo.5d5d9eef.svg\";"],"sourceRoot":""}